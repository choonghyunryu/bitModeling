% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predefined_model.R
\name{compare_info_model}
\alias{compare_info_model}
\title{Compare Model Performance with Statistics}
\usage{
compare_info_model(
  x,
  stats = c("coef", "cmat", "metrics", "quantiles"),
  nbins = 10,
  merge = FALSE
)
}
\arguments{
\item{x}{list. multi_classifiers() 결과로 생성한 모델들의 list 객체.}

\item{stats}{character. 계산/비교할 성능 평가 정보. 
c("coef", "cmat", "metrics", "quantiles")에서 선택.}

\item{nbins}{integer. 예측 확률을 비닝할 때 사용할 빈(Bins)의 개수. 
stats의 값이 "quantiles"일 경우만 적용되며 기본값은 10.}

\item{merge}{logical. 모델별 개별 결과를 하나의 tbl_df 객체로 반환할지의 여부. 
기본값은 FALSE로 개별 결과를 list의 성분으로 반환함. TRUE이면 하나의 tbl_df 객체로 반환}
}
\value{
tbl_df, conf_mat 클래스의 객체. stats의 종류에 따라 반환하는 객체의 유형이 다름.
}
\description{
multi_classifiers()로 생성한 여러 모델링의 성능 평가 및 비교를 위한 통계를 계산함
}
\details{
stats의 값이 "coef"인 경우에는 모델의 종류에 따라서, 
terms 계수나 variable importance scores를 tbl_df 객체로 반환함.
merge이 TRUE인 경우에는, classifier 변수가 추가됨 
\itemize{
\item classifier character. 모델의 종류.
\item term factor. 모델을 정의한 terms. 
\item estimate numeric. 모델을 정의한 terms의 추정 계수. 
\item penalty numeric. 모델에 사용한 penalty. 
\item `estimate > 0` logical. 추정 계수가 0보다 큰가의 여부.
\item Importance numeric. importance scores. 
\item Importance_scal numeric. 최대값 기준으로 스케일된 importance scores. 
}

stats의 값이 "cmat"일 경우에는 Confusion Matrix를 conf_mat 클래스 객체로 반환함.
merge이 TRUE인 경우에는 다음의 tbl_df 객체를 반환함.
\itemize{
\item classifier character. 모델의 종류.
\item Prediction factor. 예측 클래스. 
\item Truth factor. 실제 클레스. 
\item Freq numeric. 예측 및 실제 클래스별 돗수. 
} 

stats의 값이 "metrics"일 경우에는 성능 평가 지표를 tbl_df 클래스 객체로 반환함.
merge이 TRUE인 경우에는, classifier 변수가 추가됨 
\itemize{
\item classifier character. 모델의 종류.
\item .metric character. 성능 평가지표 이름. 
\item .estimator character. taget 변수의 데이터 유형. 
\item .estimate numeric. 성능 평가지표 값. 
}

stats의 값이 "quantiles"일 경우에는 예측 확률의 구간별 분포 정보를 tbl_df 클래스 객체로 반환함.
merge이 TRUE인 경우에는, classifier 변수가 추가됨 
\itemize{
\item classifier character. 모델의 종류.
\item binn character. 예측 확률을 비닝한 구간. 
\item n integer. 데이터 건수. 
\item positive integer. 구간에서의 positive 데이터 건수. 
\item negative integer. 구간에서의 negative 데이터 건수. 
\item prob_positive numeric. 구간에서의 positive 비율. 
\item lift numeric. 구간에서의 positive 비율에 대한 lift. 
}
}
\examples{
\donttest{
# 모델 개발을 위한 recipe 정의
data_recipe <- dlookr::heartfailure \%>\% 
  target_to(death_event) \%>\% 
  set_positive("Yes") \%>\% 
  split_dataset(prop = 0.7) \%>\% 
  extract_dataset() \%>\% 
  set_formula() \%>\% 
  step_my_center() \%>\% 
  step_my_dummy() \%>\% 
  step_my_rose()
  
# "logistic", "lasso", "elastic", "ridge", "ranger", "xgboost" classifiers를 순차 모델링
my_models <- multi_classifiers(data_recipe)

compare_info_model(my_models, "coef")
compare_info_model(my_models, "cmat")
compare_info_model(my_models, "metrics")
compare_info_model(my_models, "quantiles")

compare_info_model(my_models, "coef", merge = TRUE)
compare_info_model(my_models, "cmat", merge = TRUE)
compare_info_model(my_models, "metrics", merge = TRUE)
compare_info_model(my_models, "quantiles", merge = TRUE)

# 성능지표별로 메트릭 크기순으로 정렬
compare_info_model(my_models, "metrics", merge = TRUE) \%>\% 
  arrange(.metric, desc(.estimate)) \%>\% 
  print(n = Inf)
}
}
\seealso{
\code{\link{compare_viz_model}}
}
